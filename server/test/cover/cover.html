
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/brotigen23/goph-keeper/server/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/brotigen23/goph-keeper/server/internal/app/app.go (0.0%)</option>
				
				<option value="file2">github.com/brotigen23/goph-keeper/server/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/brotigen23/goph-keeper/server/internal/handler/handler.go (0.0%)</option>
				
				<option value="file4">github.com/brotigen23/goph-keeper/server/internal/repository/postgres/accounts.go (0.0%)</option>
				
				<option value="file5">github.com/brotigen23/goph-keeper/server/internal/repository/postgres/binary_data.go (0.0%)</option>
				
				<option value="file6">github.com/brotigen23/goph-keeper/server/internal/repository/postgres/card_data.go (61.4%)</option>
				
				<option value="file7">github.com/brotigen23/goph-keeper/server/internal/repository/postgres/metadata.go (59.0%)</option>
				
				<option value="file8">github.com/brotigen23/goph-keeper/server/internal/repository/postgres/text_data.go (61.4%)</option>
				
				<option value="file9">github.com/brotigen23/goph-keeper/server/internal/repository/postgres/users.go (71.9%)</option>
				
				<option value="file10">github.com/brotigen23/goph-keeper/server/internal/server/server.go (0.0%)</option>
				
				<option value="file11">github.com/brotigen23/goph-keeper/server/internal/service/user_data_aggregator.go (0.0%)</option>
				
				<option value="file12">github.com/brotigen23/goph-keeper/server/internal/service/user_service.go (0.0%)</option>
				
				<option value="file13">github.com/brotigen23/goph-keeper/server/pkg/crypt/crypt.go (0.0%)</option>
				
				<option value="file14">github.com/brotigen23/goph-keeper/server/pkg/logger/logger.go (60.0%)</option>
				
				<option value="file15">github.com/brotigen23/goph-keeper/server/pkg/migration/migration.go (0.0%)</option>
				
				<option value="file16">github.com/brotigen23/goph-keeper/server/pkg/pgErrors/pg_errors.go (60.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"

        "github.com/brotigen23/goph-keeper/server/internal/app"
)

// @title My API
// @version 1.0
// @description goph-keeper
// @termsOfService http://example.com/terms/
// @contact.name API Support
func main() <span class="cov0" title="0">{
        log.Println("start server... ")
        err := app.Run()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "database/sql"
        "os"
        "path/filepath"
        "time"

        "github.com/brotigen23/goph-keeper/server/internal/config"
        "github.com/brotigen23/goph-keeper/server/internal/handler"
        "github.com/brotigen23/goph-keeper/server/internal/repository/postgres"
        "github.com/brotigen23/goph-keeper/server/internal/server"
        "github.com/brotigen23/goph-keeper/server/internal/service"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
        "github.com/brotigen23/goph-keeper/server/pkg/migration"
        _ "github.com/jackc/pgx/v5/stdlib"
)

func Run() error <span class="cov0" title="0">{
        logger := logger.New().Default()

        // Config
        err := config.LoadDotEnv()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
        }</span>
        <span class="cov0" title="0">config := &amp;config.Config{}
        err = config.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
        }</span>
        <span class="cov0" title="0">logger.Info("configuration", "config", config)

        //DB
        db, err := sql.Open("pgx", config.GetPostgresDSN())
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">err = migration.Migrate(db, "file://migration/")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        // Repos
        // userRepo
        <span class="cov0" title="0">userRepo := postgres.NewUsers(nil, nil)

        // Servicies
        userService := service.NewUserService(userRepo)

        //Handler
        handler := handler.New()
        handler.SetUserService(userService)

        // Server
        server := server.New(logger, handler)

        return server.Run()</span>
}

var (
        logPath     = filepath.Join(".", "log")
        logFileName = logPath + "/" + time.Now().String() + ".log"
)

func createOrOpenLogFile(path string) (*os.File, error) <span class="cov0" title="0">{
        err := os.MkdirAll(path, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">logFile, err := os.OpenFile(logFileName, os.O_RDWR|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return logFile, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"

        "github.com/ilyakaznacheev/cleanenv"
        "github.com/jessevdk/go-flags"
        "github.com/joho/godotenv"
)

func LoadDotEnv() error <span class="cov0" title="0">{
        return godotenv.Load()
}</span>

type Config struct {
        Server struct {
                Address string `yaml:"Adress" env:"SERVER_ADDRESS" env-default:"http://localhost:8080/"`
        } `yaml:"server"`

        Database struct {
                User     string `yaml:"user" env:"DB_LOGIN"`
                Password string `yaml:"password" env:"DB_PASSWORD"`
                DBName   string `yaml:"dbname" env:"DB_NAME"`
        } `yaml:"database"`
}

func (c *Config) Load() error <span class="cov0" title="0">{
        err := cleanenv.ReadConfig("config/config.yml", c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cleanenv.ReadEnv(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = flags.Parse(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c Config) GetPostgresDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                `host=localhost port=5432 user=%s password=%s dbname=%s sslmode=disable`,
                c.Database.User, c.Database.Password, c.Database.DBName,
        )
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "net/http"

        "github.com/brotigen23/goph-keeper/server/internal/service"
)

type Handler struct {
        userService *service.UserService
}

func New() *Handler <span class="cov0" title="0">{
        return &amp;Handler{}
}</span>

func (h *Handler) SetUserService(service *service.UserService) <span class="cov0" title="0">{
        h.userService = service
}</span>

func (h Handler) Ping(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        http.Error(w, "server response", http.StatusGone)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/brotigen23/goph-keeper/server/internal/model"
        "github.com/brotigen23/goph-keeper/server/internal/repository"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
)

var accountsTable = struct {
        tableName           string
        idColumnName        string
        userIDColumnName    string
        loginColumnName     string
        passwordColumnName  string
        createdAtColumnName string
        updatedAtColumnName string
}{"accounts", "id", "user_id", "login", "password", "created_at", "updated_at"}

type accountsRepository struct {
        db     *sql.DB
        logger *logger.Logger
}

func NewAccounts(db *sql.DB, logger *logger.Logger) repository.Accounts <span class="cov0" title="0">{
        return &amp;accountsRepository{
                db:     db,
                logger: logger}
}</span>

func (r accountsRepository) Create(ctx context.Context, userID int, login, password string) (*model.AccountData, error) <span class="cov0" title="0">{
        ret := &amp;model.AccountData{
                UserID:   userID,
                Login:    login,
                Password: password,
        }
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">query := fmt.Sprintf("INSERT INTO %s(%s, %s, %s) VALUES($1, $2) RETURNING %s, %s",
                accountsTable.tableName,
                accountsTable.userIDColumnName,
                accountsTable.loginColumnName,
                accountsTable.passwordColumnName,
                accountsTable.idColumnName,
                accountsTable.createdAtColumnName)

        err = tx.QueryRowContext(ctx, query, userID, login, password).Scan(&amp;ret.ID, &amp;ret.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                rollbackErr := tx.Rollback()
                if rollbackErr != nil </span><span class="cov0" title="0">{
                        return nil, rollbackErr
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ret.UpdatedAt = ret.CreatedAt
        return ret, nil</span>
}

func (r accountsRepository) GetByID(ctx context.Context, id int) (*model.AccountData, error) <span class="cov0" title="0">{
        ret := &amp;model.AccountData{}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s, %s FROM %s WHERE %s = $1",
                accountsTable.userIDColumnName,
                accountsTable.loginColumnName,
                accountsTable.passwordColumnName,
                accountsTable.createdAtColumnName,
                accountsTable.updatedAtColumnName,
                accountsTable.tableName,
                accountsTable.idColumnName)

        err := r.db.QueryRow(query, id).
                Scan(&amp;ret.UserID,
                        &amp;ret.Login,
                        &amp;ret.Password,
                        &amp;ret.CreatedAt,
                        &amp;ret.UpdatedAt)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                break</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                r.logger.Info("account not found", "id", id)
                return nil, repository.ErrAccountsDataNotFound</span>
        default:<span class="cov0" title="0">
                r.logger.Error(err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}
func (r accountsRepository) GetByUserID(ctx context.Context, userID int) ([]model.AccountData, error) <span class="cov0" title="0">{

        ret := []model.AccountData{}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s, %s FROM %s WHERE %s = $1",
                accountsTable.idColumnName,
                accountsTable.loginColumnName,
                accountsTable.passwordColumnName,
                accountsTable.createdAtColumnName,
                accountsTable.updatedAtColumnName,
                accountsTable.tableName,
                accountsTable.userIDColumnName)

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                ret = append(ret, model.AccountData{UserID: userID})
                err = rows.Scan(
                        &amp;ret[len(ret)-1].ID,
                        &amp;ret[len(ret)-1].Login,
                        &amp;ret[len(ret)-1].Password,
                        &amp;ret[len(ret)-1].CreatedAt,
                        &amp;ret[len(ret)-1].UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error(err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if len(ret) == 0 </span><span class="cov0" title="0">{
                return nil, repository.ErrAccountsDataNotFound
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func (r accountsRepository) Update(context.Context, model.AccountData) (*model.AccountData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (r accountsRepository) DeleteByID(context.Context, int) (*model.AccountData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/brotigen23/goph-keeper/server/internal/model"
        "github.com/brotigen23/goph-keeper/server/internal/repository"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
)

var binaryTable = struct {
        tableName string

        idColumnName     string
        userIDColumnName string

        dataColumnName string

        createdAtColumnName string
        updatedAtColumnName string
}{"binary_data", "id", "user_id", "data", "created_at", "updated_at"}

type binaryRepository struct {
        db     *sql.DB
        logger *logger.Logger
}

func NewBinary(db *sql.DB, logger *logger.Logger) repository.Binary <span class="cov0" title="0">{
        return &amp;binaryRepository{
                db:     db,
                logger: logger}
}</span>

func (r binaryRepository) Create(ctx context.Context, userID int, data []byte) (*model.BinaryData, error) <span class="cov0" title="0">{

        ret := &amp;model.BinaryData{
                UserID: userID,
                Data:   data,
        }
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">query := fmt.Sprintf("INSERT INTO %s(%s, %s) VALUES($1, $2) RETURNING %s, %s",
                binaryTable.tableName,
                binaryTable.userIDColumnName,
                binaryTable.dataColumnName,
                binaryTable.idColumnName,
                binaryTable.createdAtColumnName)

        err = tx.QueryRowContext(ctx, query, userID, data).Scan(&amp;ret.ID, &amp;ret.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                rollbackErr := tx.Rollback()
                if rollbackErr != nil </span><span class="cov0" title="0">{
                        return nil, rollbackErr
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ret.UpdatedAt = ret.CreatedAt
        return ret, nil</span>
}

func (r binaryRepository) GetByID(ctx context.Context, id int) (*model.BinaryData, error) <span class="cov0" title="0">{

        ret := &amp;model.BinaryData{ID: id}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s FROM %s WHERE %s = $1",
                binaryTable.userIDColumnName,
                binaryTable.dataColumnName,
                binaryTable.createdAtColumnName,
                binaryTable.updatedAtColumnName,
                binaryTable.tableName,
                binaryTable.idColumnName)

        err := r.db.QueryRowContext(ctx, query, id).
                Scan(&amp;ret.UserID,
                        &amp;ret.Data,
                        &amp;ret.CreatedAt,
                        &amp;ret.UpdatedAt)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                break</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                r.logger.Info("text data not found", "id", id)
                // TODO: return error
                return nil, repository.ErrUserNotFound</span>
        default:<span class="cov0" title="0">
                r.logger.Error(err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}
func (r binaryRepository) GetByUserID(ctx context.Context, userID int) ([]model.BinaryData, error) <span class="cov0" title="0">{

        ret := []model.BinaryData{}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s FROM %s WHERE %s = $1",
                textDataTable.idColumnName,
                textDataTable.dataColumnName,
                textDataTable.createdAtColumnName,
                textDataTable.updatedAtColumnName,
                textDataTable.tableName,
                textDataTable.userIDColumnName)

        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                ret = append(ret, model.BinaryData{UserID: userID})
                err = rows.Scan(
                        &amp;ret[len(ret)-1].ID,
                        &amp;ret[len(ret)-1].Data,
                        &amp;ret[len(ret)-1].CreatedAt,
                        &amp;ret[len(ret)-1].UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error(err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}

func (r binaryRepository) Update(context.Context, model.BinaryData) (*model.BinaryData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (r binaryRepository) DeleteByID(context.Context, int) (*model.BinaryData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/brotigen23/goph-keeper/server/internal/model"
        "github.com/brotigen23/goph-keeper/server/internal/repository"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
)

var cardsTable = struct {
        tableName string

        idColumnName     string
        userIDColumnName string

        numberColumnName         string
        cardholderNameColumnName string
        expireColumnName         string
        cvvColumnName            string

        createdAtColumnName string
        updatedAtColumnName string
}{"cards_data", "id", "user_id", "number", "cardholder_name", "expire", "cvv", "created_at", "updated_at"}

type cardsRepository struct {
        db     *sql.DB
        logger *logger.Logger
}

func NewCardsRepository(db *sql.DB, logger *logger.Logger) repository.Cards <span class="cov8" title="1">{
        return &amp;cardsRepository{
                db:     db,
                logger: logger}
}</span>

func (r cardsRepository) Create(
        ctx context.Context,
        userID int, number, cardholderName string,
        expireAt time.Time, cvv string) (*model.CardData, error) <span class="cov8" title="1">{

        ret := &amp;model.CardData{
                UserID:         userID,
                Number:         number,
                CardholderName: cardholderName,
                Expire:         expireAt,
                CVV:            cvv,
        }
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf("INSERT INTO %s(%s, %s, %s, %s, %s) VALUES($1, $2, $3, $4) RETURNING %s, %s",
                cardsTable.tableName,
                cardsTable.userIDColumnName,
                cardsTable.numberColumnName,
                cardsTable.cardholderNameColumnName,
                cardsTable.expireColumnName,
                cardsTable.cvvColumnName,
                cardsTable.idColumnName,
                cardsTable.createdAtColumnName)

        err = tx.QueryRowContext(ctx, query, userID, number, cardholderName, expireAt, cvv).Scan(&amp;ret.ID, &amp;ret.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                rollbackErr := tx.Rollback()
                if rollbackErr != nil </span><span class="cov0" title="0">{
                        return nil, rollbackErr
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret.UpdatedAt = ret.CreatedAt
        return ret, nil</span>
}

func (r cardsRepository) GetByID(ctx context.Context, id int) (*model.CardData, error) <span class="cov8" title="1">{

        ret := &amp;model.CardData{ID: id}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s = $1",
                cardsTable.userIDColumnName,
                cardsTable.numberColumnName,
                cardsTable.cardholderNameColumnName,
                cardsTable.expireColumnName,
                cardsTable.cvvColumnName,
                cardsTable.createdAtColumnName,
                cardsTable.updatedAtColumnName,
                cardsTable.tableName,
                cardsTable.idColumnName)

        err := r.db.QueryRowContext(ctx, query, id).
                Scan(&amp;ret.UserID,
                        &amp;ret.Number,
                        &amp;ret.CardholderName,
                        &amp;ret.Expire,
                        &amp;ret.CVV,
                        &amp;ret.CreatedAt,
                        &amp;ret.UpdatedAt)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                break</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                r.logger.Info("card info not found", "id", id)
                // TODO: return error
                return nil, repository.ErrCardsDataNotFound</span>
        default:<span class="cov0" title="0">
                r.logger.Error(err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return ret, nil</span>
}
func (r cardsRepository) GetByUserID(ctx context.Context, userID int) ([]model.CardData, error) <span class="cov8" title="1">{

        ret := []model.CardData{}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s = $1",
                cardsTable.idColumnName,
                cardsTable.numberColumnName,
                cardsTable.cardholderNameColumnName,
                cardsTable.expireColumnName,
                cardsTable.cvvColumnName,
                cardsTable.createdAtColumnName,
                cardsTable.updatedAtColumnName,
                cardsTable.tableName,
                cardsTable.userIDColumnName)

        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                ret = append(ret, model.CardData{UserID: userID})
                err = rows.Scan(
                        &amp;ret[len(ret)-1].ID,
                        &amp;ret[len(ret)-1].Number,
                        &amp;ret[len(ret)-1].CardholderName,
                        &amp;ret[len(ret)-1].Expire,
                        &amp;ret[len(ret)-1].CVV,
                        &amp;ret[len(ret)-1].CreatedAt,
                        &amp;ret[len(ret)-1].UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error(err)
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if len(ret) == 0 </span><span class="cov0" title="0">{
                return nil, repository.ErrCardsDataNotFound
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (r cardsRepository) Update(context.Context, model.CardData) (*model.CardData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (r cardsRepository) DeleteByID(context.Context, int) (*model.CardData, error) <span class="cov0" title="0">{ return nil, nil }</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/brotigen23/goph-keeper/server/internal/model"
        "github.com/brotigen23/goph-keeper/server/internal/repository"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
)

var metadataTable = struct {
        tableName string

        idColumnName        string
        tableNameColumnName string
        rowIDColumnName     string

        dataColumnName string

        createdAtColumnName string
        updatedAtColumnName string
}{"metadata", "id", "table_name", "row_id", "data", "created_at", "updated_at"}

type metadataRepository struct {
        db     *sql.DB
        logger *logger.Logger
}

func NewMetadataRepository(db *sql.DB, logger *logger.Logger) repository.Metadata <span class="cov8" title="1">{
        return &amp;metadataRepository{
                db:     db,
                logger: logger}
}</span>

func (r metadataRepository) Create(ctx context.Context, tableName string, rowID int, data string) (*model.Metadata, error) <span class="cov8" title="1">{

        ret := &amp;model.Metadata{
                TableName: tableName,
                RowID:     rowID,
                Data:      data,
        }
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf("INSERT INTO %s(%s, %s, %s) VALUES($1, $2, $3) RETURNING %s, %s",
                metadataTable.tableName,
                metadataTable.tableNameColumnName,
                metadataTable.rowIDColumnName,
                metadataTable.dataColumnName,
                metadataTable.idColumnName,
                metadataTable.createdAtColumnName)

        err = tx.QueryRowContext(ctx, query, tableName, rowID, data).Scan(&amp;ret.ID, &amp;ret.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                rollbackErr := tx.Rollback()
                if rollbackErr != nil </span><span class="cov0" title="0">{
                        return nil, rollbackErr
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret.UpdatedAt = ret.CreatedAt
        return ret, nil</span>
}

func (r metadataRepository) GetByID(ctx context.Context, id int) (*model.Metadata, error) <span class="cov8" title="1">{

        ret := &amp;model.Metadata{ID: id}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s, %s FROM %s WHERE %s = $1",
                metadataTable.tableNameColumnName,
                metadataTable.rowIDColumnName,
                metadataTable.dataColumnName,
                metadataTable.createdAtColumnName,
                metadataTable.updatedAtColumnName,
                metadataTable.tableName,
                metadataTable.idColumnName)

        err := r.db.QueryRowContext(ctx, query, id).
                Scan(&amp;ret.TableName,
                        &amp;ret.RowID,
                        &amp;ret.Data,
                        &amp;ret.CreatedAt,
                        &amp;ret.UpdatedAt)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                break</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                r.logger.Info("text data not found", "id", id)
                // TODO: return error
                return nil, repository.ErrMetadataNotFound</span>
        default:<span class="cov0" title="0">
                r.logger.Error(err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return ret, nil</span>
}
func (r metadataRepository) GetByRowID(ctx context.Context, tableName string, rowID int) (*model.Metadata, error) <span class="cov8" title="1">{

        ret := &amp;model.Metadata{TableName: tableName, RowID: rowID}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s FROM %s WHERE %s = $1 AND %s = $2",
                metadataTable.idColumnName,
                metadataTable.dataColumnName,
                metadataTable.createdAtColumnName,
                metadataTable.updatedAtColumnName,
                metadataTable.tableName,
                metadataTable.tableNameColumnName,
                metadataTable.rowIDColumnName)

        err := r.db.QueryRowContext(ctx, query, tableName, rowID).
                Scan(&amp;ret.ID,
                        &amp;ret.Data,
                        &amp;ret.CreatedAt,
                        &amp;ret.UpdatedAt)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                break</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                r.logger.Info("metadata not found", "row id", rowID)
                return nil, repository.ErrMetadataNotFound</span>
        default:<span class="cov0" title="0">
                r.logger.Error(err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return ret, nil</span>
}

func (r metadataRepository) Update(context.Context, model.Metadata) (*model.Metadata, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (r metadataRepository) DeleteByID(context.Context, int) (*model.Metadata, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/brotigen23/goph-keeper/server/internal/model"
        "github.com/brotigen23/goph-keeper/server/internal/repository"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
)

var textDataTable = struct {
        tableName           string
        idColumnName        string
        userIDColumnName    string
        dataColumnName      string
        createdAtColumnName string
        updatedAtColumnName string
}{"text_data", "id", "user_id", "data", "created_at", "updated_at"}

type textRepository struct {
        db     *sql.DB
        logger *logger.Logger
}

func NewTextDataRepository(db *sql.DB, logger *logger.Logger) repository.Text <span class="cov8" title="1">{
        return &amp;textRepository{
                db:     db,
                logger: logger}
}</span>

func (r textRepository) Create(ctx context.Context, userID int, data string) (*model.TextData, error) <span class="cov8" title="1">{

        ret := &amp;model.TextData{
                UserID: userID,
                Data:   data,
        }
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf("INSERT INTO %s(%s, %s) VALUES($1, $2) RETURNING %s, %s",
                textDataTable.tableName,
                textDataTable.userIDColumnName,
                textDataTable.dataColumnName,
                textDataTable.idColumnName,
                textDataTable.createdAtColumnName)

        err = tx.QueryRowContext(ctx, query, userID, data).Scan(&amp;ret.ID, &amp;ret.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                rollbackErr := tx.Rollback()
                if rollbackErr != nil </span><span class="cov0" title="0">{
                        return nil, rollbackErr
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret.UpdatedAt = ret.CreatedAt
        return ret, nil</span>
}

func (r textRepository) GetByID(ctx context.Context, id int) (*model.TextData, error) <span class="cov8" title="1">{

        ret := &amp;model.TextData{ID: id}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s FROM %s WHERE %s = $1",
                textDataTable.userIDColumnName,
                textDataTable.dataColumnName,
                textDataTable.createdAtColumnName,
                textDataTable.updatedAtColumnName,
                textDataTable.tableName,
                textDataTable.idColumnName)

        err := r.db.QueryRowContext(ctx, query, id).
                Scan(&amp;ret.UserID,
                        &amp;ret.Data,
                        &amp;ret.CreatedAt,
                        &amp;ret.UpdatedAt)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                break</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                r.logger.Info("text data not found", "id", id)
                return nil, repository.ErrTextDataNotFound</span>
        default:<span class="cov0" title="0">
                r.logger.Error(err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return ret, nil</span>
}
func (r textRepository) GetByUserID(ctx context.Context, userID int) ([]model.TextData, error) <span class="cov8" title="1">{

        ret := []model.TextData{}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s FROM %s WHERE %s = $1",
                textDataTable.idColumnName,
                textDataTable.dataColumnName,
                textDataTable.createdAtColumnName,
                textDataTable.updatedAtColumnName,
                textDataTable.tableName,
                textDataTable.userIDColumnName)

        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                ret = append(ret, model.TextData{UserID: userID})
                err = rows.Scan(
                        &amp;ret[len(ret)-1].ID,
                        &amp;ret[len(ret)-1].Data,
                        &amp;ret[len(ret)-1].CreatedAt,
                        &amp;ret[len(ret)-1].UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error(err)
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(ret) == 0 </span><span class="cov0" title="0">{
                return nil, repository.ErrTextDataNotFound
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (r textRepository) Update(context.Context, model.TextData) (*model.TextData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (r textRepository) DeleteByID(context.Context, int) (*model.TextData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/brotigen23/goph-keeper/server/internal/model"
        "github.com/brotigen23/goph-keeper/server/internal/repository"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
        "github.com/brotigen23/goph-keeper/server/pkg/pgErrors"
)

var userTable = struct {
        tableName           string
        idColumnName        string
        loginColumnName     string
        passwordColumnName  string
        createdAtColumnName string
        updatedAtColumnName string
}{"users", "id", "login", "password", "created_at", "updated_at"}

type usersRepository struct {
        db     *sql.DB
        logger *logger.Logger
}

func NewUsers(db *sql.DB, logger *logger.Logger) repository.Users <span class="cov8" title="1">{
        return &amp;usersRepository{
                db:     db,
                logger: logger,
        }
}</span>

func (r usersRepository) Create(ctx context.Context, login, password string) (*model.User, error) <span class="cov8" title="1">{

        ret := &amp;model.User{
                Login:    login,
                Password: password,
        }
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf("INSERT INTO %s(%s, %s) VALUES($1, $2) RETURNING %s, %s",
                userTable.tableName,
                userTable.loginColumnName,
                userTable.passwordColumnName,
                userTable.idColumnName,
                userTable.createdAtColumnName)

        err = tx.QueryRowContext(ctx, query, login, password).Scan(&amp;ret.ID, &amp;ret.CreatedAt)
        if err != nil </span><span class="cov8" title="1">{
                rollbackErr := tx.Rollback()
                if rollbackErr != nil </span><span class="cov0" title="0">{
                        return nil, rollbackErr
                }</span>
                <span class="cov8" title="1">if pgErrors.CheckIfUniqueViolation(err) </span><span class="cov8" title="1">{
                        return nil, repository.ErrUserExists
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret.UpdatedAt = ret.CreatedAt
        return ret, nil</span>
}

func (r usersRepository) GetByID(ctx context.Context, id int) (*model.User, error) <span class="cov8" title="1">{
        ret := &amp;model.User{}

        query := fmt.Sprintf("SELECT %s, %s, %s, %s, %s FROM %s WHERE %s = $1",
                userTable.idColumnName,
                userTable.loginColumnName,
                userTable.passwordColumnName,
                userTable.createdAtColumnName,
                userTable.updatedAtColumnName,
                userTable.tableName,
                userTable.idColumnName)

        err := r.db.QueryRowContext(ctx, query, id).
                Scan(&amp;ret.ID, &amp;ret.Login, &amp;ret.Password, &amp;ret.CreatedAt, &amp;ret.UpdatedAt)

        switch err </span>{
        case nil:<span class="cov8" title="1">
                break</span>
        case sql.ErrNoRows:<span class="cov8" title="1">
                r.logger.Info("user not found", "userID", id)
                return nil, repository.ErrUserNotFound</span>
        default:<span class="cov0" title="0">
                r.logger.Error(err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return ret, nil</span>
}

func (r usersRepository) GetByLogin(ctx context.Context, login string) (*model.User, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (r usersRepository) Update(ctx context.Context, user model.User) (*model.User, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (r usersRepository) DeleteByID(ctx context.Context, id int) (*model.User, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "context"
        "net/http"
        "os/signal"
        "syscall"
        "time"

        "github.com/brotigen23/goph-keeper/server/internal/handler"
        "github.com/brotigen23/goph-keeper/server/pkg/logger"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

type Server struct {
        handler *handler.Handler
        logger  *logger.Logger

        // Service
        server *http.Server
        // middleware
}

func New(logger *logger.Logger, handler *handler.Handler) *Server <span class="cov0" title="0">{
        return &amp;Server{
                handler: handler,

                logger: logger,
        }
}</span>

func (s Server) Run() error <span class="cov0" title="0">{
        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        router := chi.NewRouter()
        router.Use(middleware.Logger)

        router.Get("/ping", s.handler.Ping)

        s.server = &amp;http.Server{
                Addr:    ":8080",
                Handler: router,
        }

        ////////////////////////////////////////////////////
        // START
        ////////////////////////////////////////////////////
        s.logger.Info("server is running")

        start := time.Now()
        go func() </span><span class="cov0" title="0">{
                if e := s.server.ListenAndServe(); e != nil &amp;&amp; e != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Error(e)
                }</span>
        }()

        <span class="cov0" title="0">&lt;-ctx.Done()
        s.logger.Info("server is shutting down")

        stop()

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := s.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">uptime := time.Since(start).Seconds()
        s.logger.Info("uptime", "time", uptime)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package service

type UserDataAggregator struct {
        // Servicies
}

func NewAggregator() *UserDataAggregator <span class="cov0" title="0">{
        return &amp;UserDataAggregator{}
}</span>

func (a UserDataAggregator) GetUserAccountsData() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package service

import (
        "context"

        "github.com/brotigen23/goph-keeper/server/internal/model"
        "github.com/brotigen23/goph-keeper/server/internal/repository"
        "github.com/brotigen23/goph-keeper/server/pkg/crypt"
)

type UserService struct {
        repo repository.Users
}

func NewUserService(repo repository.Users) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                repo: repo,
        }
}</span>

func (s UserService) Create(login, password string) (*model.User, error) <span class="cov0" title="0">{
        // Check if user already exists
        existUser, err := s.GetUserByLogin(login)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                return existUser, ErrUserExists</span>
        case repository.ErrUserNotFound:<span class="cov0" title="0">
                break</span>
        default:<span class="cov0" title="0">
                return nil, err</span>
        }
        // Hash password
        <span class="cov0" title="0">passHash, err := crypt.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Create
        <span class="cov0" title="0">user, err := s.repo.Create(context.Background(), login, passHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (s UserService) GetUserByLogin(login string) (*model.User, error) <span class="cov0" title="0">{

        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package crypt

import (
        "golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(hash), nil</span>
}

func CheckPasswordHash(password, hash string) error <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package logger

import (
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
        "time"
)

// Logger
type Logger struct {
        logger *slog.Logger

        logFile *os.File
}

func New() *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                logger: nil,
        }
}</span>

func (l *Logger) Default() *Logger <span class="cov8" title="1">{
        logPath := filepath.Join(".", "log")
        logFileName := logPath + "/" + time.Now().String() + ".log"

        err := os.MkdirAll(logPath, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">l.logFile, err = os.OpenFile(logFileName, os.O_RDWR|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">l.logger = slog.New(slog.NewJSONHandler(l.logFile, nil))

        return l</span>
}

func (l *Logger) Testing() *Logger <span class="cov0" title="0">{
        l.logger = slog.New(slog.NewTextHandler(os.Stderr, nil))

        return l
}</span>

func (l Logger) Error(err error) <span class="cov8" title="1">{
        _, file, line, ok := runtime.Caller(1)
        if !ok </span><span class="cov0" title="0">{
                l.logger.Error("Error occurred", slog.String("error", "could not retrieve file/line"))
                return
        }</span>
        <span class="cov8" title="1">l.logger.Error(
                "Error occured",
                "error", err.Error(),
                slog.String("file", file), slog.Int("line", line))</span>
}

func (l Logger) Info(msg string, args ...any) <span class="cov0" title="0">{
        l.logger.Info(msg, args...)
}</span>

func (l Logger) CloseFile() <span class="cov0" title="0">{
        l.logFile.Close()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package migration

import (
        "database/sql"

        "github.com/golang-migrate/migrate"
        "github.com/golang-migrate/migrate/database/postgres"
        _ "github.com/golang-migrate/migrate/source/file"
        _ "github.com/lib/pq"
)

func Migrate(db *sql.DB, path string) error <span class="cov0" title="0">{
        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(path, "pq", driver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = m.Up()
        errSource, errDB := m.Close()
        if errSource != nil </span><span class="cov0" title="0">{
                return errSource
        }</span>
        <span class="cov0" title="0">if errDB != nil </span><span class="cov0" title="0">{
                return errDB
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package pgErrors

import (
        "github.com/jackc/pgerrcode"
        "github.com/lib/pq"
)

func CheckIfUniqueViolation(err error) bool <span class="cov8" title="1">{
        if pqErr, ok := err.(*pq.Error); ok </span><span class="cov8" title="1">{
                if pqErr.Code == pgerrcode.UniqueViolation </span><span class="cov8" title="1">{
                        return true
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
